name: Backend CI

on:
  pull_request:
    paths:
      - "motionit/**"
      - ".github/**"
  push:
    branches: [ main, develop ]

permissions:
  contents: read
  checks: write
  pull-requests: write

jobs:
  backend-test:
    runs-on: ubuntu-latest

    defaults:
      run:
        working-directory: motionit

    # ğŸ”‘ ì—¬ê¸°ì„œ GitHub Secrets â†’ Springì´ ì°¸ì¡°í•˜ëŠ” í™˜ê²½ë³€ìˆ˜ëª…ìœ¼ë¡œ ë§¤í•‘
    # application.yml ì˜ ${...} í‚¤ì™€ "ì •í™•íˆ ê°™ì€ ì´ë¦„"ìœ¼ë¡œ ë‘ë©´ .env ì—†ì´ë„ ë™ì‘í•©ë‹ˆë‹¤.
    env:
      # Spring ì‹¤í–‰ í”„ë¡œí•„: CI/H2ìš©
      SPRING_PROFILES_ACTIVE: test
      # H2ë¡œ í…ŒìŠ¤íŠ¸ (í•„ìš” ì‹œ YourTestConfigì— ë§ê²Œ ì¡°ì •)
      SPRING_DATASOURCE_URL: jdbc:h2:mem:testdb;MODE=MySQL;DB_CLOSE_DELAY=-1;DATABASE_TO_UPPER=false
      SPRING_DATASOURCE_USERNAME: sa
      SPRING_DATASOURCE_PASSWORD: ""

      # ====== appì—ì„œ ì°¸ì¡°í•˜ëŠ” í‚¤ë“¤ ======
      AWS_ACCESS_KEY:        ${{ secrets.AWS_ACCESS_KEY }}
      AWS_SECRET_KEY:        ${{ secrets.AWS_SECRET_KEY }}
      AWS_S3_BUCKET_NAME:    ${{ secrets.AWS_S3_BUCKET_NAME }}
      AWS_CLOUDFRONT_DOMAIN: ${{ secrets.AWS_CLOUDFRONT_DOMAIN }}
      AWS_CLOUDFRONT_KEY_ID: ${{ secrets.AWS_CLOUDFRONT_KEY_ID }}
      # CloudFront í”„ë¼ì´ë¹—í‚¤ëŠ” ë³´í†µ íŒŒì¼ ê²½ë¡œê°€ í•„ìš”í•©ë‹ˆë‹¤.
      # í…ŒìŠ¤íŠ¸ì—ì„œëŠ” ì‚¬ìš©í•˜ì§€ ì•Šê²Œ ë¶„ê¸°í•˜ëŠ” í¸ì´ ì•ˆì „í•˜ì§€ë§Œ,
      # ì„ì‹œë¡œ /tmp/key.pem ê²½ë¡œì— ì¨ë‘ê³  ê²½ë¡œë§Œ ì£¼ì…í•´ë„ ë©ë‹ˆë‹¤. (ì•„ë˜ "ì˜µì…˜: í‚¤ íŒŒì¼ ìƒì„±" ì°¸ê³ )
      AWS_CLOUDFRONT_PRIVATE_KEY_PATH: /tmp/cloudfront_key.pem
      AWS_CLOUDFRONT_PRIVATE_KEY_PEM: ${{ secrets.AWS_CLOUDFRONT_PRIVATE_KEY_PEM }}

      JWT_SECRET:               ${{ secrets.JWT_SECRET }}
      JWT_ACCESS_TOKEN_EXPIRATION: "3600"
      JWT_REFRESH_TOKEN_EXPIRATION: "1209600"

      OPENAI_API_KEY:         ${{ secrets.OPENAI_API_KEY }}
      YOUTUBE_API_KEY:        ${{ secrets.YOUTUBE_API_KEY }}
      KAKAO_CLIENT_ID:        ${{ secrets.KAKAO_CLIENT_ID }}

      # í”„ë¡ íŠ¸ ë¦¬ë‹¤ì´ë ‰íŠ¸ ì£¼ì†Œ ë“± í…ŒìŠ¤íŠ¸ìš© ê¸°ë³¸ê°’
      # í•„ìš”ì‹œ Secretsë¡œ ë¹¼ë„ ë¨
      # app.oauth2.redirect-urlì€ application.ymlì— ìƒìˆ˜ë¡œ ìˆìœ¼ë‹ˆ ë³´í†µ ë¶ˆí•„ìš”

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Java 21
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 21

      - name: Grant execute permission for Gradle Wrapper
        run: chmod +x gradlew

      - name: Write application-test.yml from secret
        working-directory: motionit
        run: |
          mkdir -p src/test/resources
          cat > src/test/resources/application-test.yml <<'YAML'
          ${{ secrets.APPLICATION_TEST_YML }}
          YAML

      - name: Show test resources
        working-directory: motionit
        run: ls -al src/test/resources || true

      # (ì˜µì…˜) CloudFront í”„ë¼ì´ë¹— í‚¤ íŒŒì¼ ìƒì„± â€” í…ŒìŠ¤íŠ¸ ì½”ë“œê°€ í•´ë‹¹ íŒŒì¼ì„ ì ‘ê·¼í•œë‹¤ë©´ í•„ìš”
      - name: Write CloudFront private key (optional)
        if: ${{ env.AWS_CLOUDFRONT_PRIVATE_KEY_PATH != '' && env.AWS_CLOUDFRONT_PRIVATE_KEY_PEM != '' }}
        run: |
          printf "%s" "$AWS_CLOUDFRONT_PRIVATE_KEY_PEM" > "$AWS_CLOUDFRONT_PRIVATE_KEY_PATH"
          chmod 600 "$AWS_CLOUDFRONT_PRIVATE_KEY_PATH"

      # ì „ì²´(ë‹¨ìœ„+í†µí•©) ì‹¤í–‰
      - name: Run Full Test
        run: ./gradlew --no-daemon clean fullTest --info --stacktrace

      - name: Generate JaCoCo (fullTest)
        run: ./gradlew clean jacocoFullTestReport --rerun-tasks --no-daemon

      # ì‹¤íŒ¨/ì„±ê³µê³¼ ë¬´ê´€í•˜ê²Œ ë¦¬í¬íŒ… ë‹¨ê³„ëŠ” ì§„í–‰
      - name: Publish Unit Test Results (JUnit)
        if: always()
        uses: EnricoMi/publish-unit-test-result-action@v2
        with:
          files: |
            motionit/build/test-results/test/*.xml
            motionit/build/test-results/fullTest/*.xml
          check_run: true
          comment_mode: always

      - name: Upload failed-tests.txt (if exists)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: failed-tests
          path: motionit/build/reports/tests/failed-tests.txt
          if-no-files-found: ignore

      - name: Upsert PR comment with failed tests
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = 'motionit/build/reports/tests/failed-tests.txt';
            const MARK = '<!-- FAILED-TESTS-SUMMARY -->';

            function buildBody(textBlock) {
              return [
                MARK,
                '### âŒ Failed Tests (from Gradle summary)',
                '',
                '<details><summary>Expand</summary>',
                '',
                '```text',
                textBlock,
                '```',
                '',
                '</details>'
              ].join('\n');
            }

            if (!context.payload.pull_request) {
              core.info('Not a PR event, skip commenting');
              return;
            }

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              per_page: 100
            });

            // íŒŒì¼ì´ ì—†ê±°ë‚˜, No failuresë©´ ê¸°ì¡´ ë§ˆì»¤ ëŒ“ê¸€ ì‚­ì œ
            if (!fs.existsSync(path)) {
              const existing = comments.find(c => c.user.type === 'Bot' && c.body.includes(MARK));
              if (existing) {
                await github.rest.issues.deleteComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existing.id
                });
              }
              return;
            }

            const content = fs.readFileSync(path, 'utf8').trim();
            if (!content || content === 'No failures ğŸ‰') {
              const existing = comments.find(c => c.user.type === 'Bot' && c.body.includes(MARK));
              if (existing) {
                await github.rest.issues.deleteComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existing.id
                });
              }
              return;
            }

            const body = buildBody(content);
            const existing = comments.find(c => c.user.type === 'Bot' && c.body.includes(MARK));
            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body
              });
            }

      - name: Upload JaCoCo HTML
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: jacoco-full-html
          path: motionit/build/reports/jacocoFull/html
          if-no-files-found: warn

      - name: Install xmllint
        if: always()
        run: sudo apt-get update && sudo apt-get install -y libxml2-utils

      - name: Compute coverage & upsert PR comment
        if: always() && github.event_name == 'pull_request'
        id: cov
        run: |
          ls -al build/reports/jacocoFull/xml || true
          ls -al build/reports/jacoco/xml || true
          ls -al build/jacoco || true
          
          # í•˜ë‚˜ì˜ ë¦¬í¬íŠ¸ë¡œ ì˜ˆ: fullTest ê¸°ì¤€
          XML="build/reports/jacocoFull/xml/jacocoFullTestReport.xml"
          if [ ! -f "$XML" ]; then
            echo "XML not found: $XML"
            ALT="build/reports/jacoco/xml/jacocoTestReport.xml"
            if [ -f "$ALT" ]; then
              XML="$ALT"
            else
              echo "pct=0" >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          COVERED=$(xmllint --xpath "string(sum(//counter[@type='LINE']/@covered))" "$XML")
          MISSED=$(xmllint --xpath "string(sum(//counter[@type='LINE']/@missed))" "$XML")
          TOTAL=$(( ${COVERED%.*} + ${MISSED%.*} ))
          PCT=0
          if [ "$TOTAL" -ne 0 ]; then
            # ì†Œìˆ˜ì  2ìë¦¬
            PCT=$(awk "BEGIN { printf \"%.2f\", ($COVERED/($COVERED+$MISSED))*100 }")
          fi
          echo "pct=$PCT" >> $GITHUB_OUTPUT
        shell: bash

      - name: Build detailed coverage markdown (incl. Changed Files)
        if: always() && github.event_name == 'pull_request'
        id: covmd
        run: |
          # ë¦¬í¬íŠ¸ ê²½ë¡œ í™•ì¸
          XML="build/reports/jacocoFull/xml/jacocoFullTestReport.xml"
          if [ ! -f "$XML" ]; then
            ALT="build/reports/jacoco/xml/jacocoTestReport.xml"
            if [ -f "$ALT" ]; then
              XML="$ALT"
            else
              echo "details=No coverage report found." >> $GITHUB_OUTPUT
              exit 0
            fi
          fi

          # PR ë³€ê²½ íŒŒì¼ ëª©ë¡(ìë°”/ì½”í‹€ë¦°)ë§Œ ìˆ˜ì§‘
          git diff --name-only "${{ github.event.pull_request.base.sha }}" "${{ github.sha }}" \
            | grep -E '^motionit/src/main/(java|kotlin)/.*\.(java|kt)$' \
            | sed 's#^motionit/##' > /tmp/changed-java.txt || true

          echo "Changed files (main src):"
          cat /tmp/changed-java.txt || true
          echo

          python3 - <<'PY' > /tmp/coverage_details.md
          import xml.etree.ElementTree as ET
          from pathlib import Path

          xml_path = Path(r"""${XML}""")
          root = ET.parse(xml_path).getroot()

          def sum_counter(node, ctype):
              for c in node.findall("counter"):
                  if c.get("type") == ctype:
                      return int(c.get("covered", "0")), int(c.get("missed", "0"))
              return 0, 0

          # ì „ì²´ ìš”ì•½
          tot_cov, tot_miss = sum_counter(root, "LINE")
          tot_pct = (tot_cov / (tot_cov + tot_miss) * 100) if (tot_cov + tot_miss) else 0.0

          # íŒ¨í‚¤ì§€ ìš”ì•½ (ë‚®ì€ ì»¤ë²„ë¦¬ì§€ ìˆœ)
          pkg_rows = []
          for p in root.findall("package"):
              pcov, pmiss = sum_counter(p, "LINE")
              if pcov + pmiss == 0:
                  for c in p.findall("class"):
                      cc, cm = sum_counter(c, "LINE")
                      pcov += cc; pmiss += cm
              ppct = (pcov / (pcov + pmiss) * 100) if (pcov + pmiss) else 0.0
              pkg_rows.append((p.get("name","(default)"), pcov, pmiss, ppct))
          pkg_rows.sort(key=lambda r: r[3])  # pct ì˜¤ë¦„ì°¨ìˆœ

          # í´ë˜ìŠ¤ë³„ ìƒì„¸
          class_rows = []  # (pkg, classFqn, covered, missed, pct, total)
          for p in root.findall("package"):
              pkg = p.get("name","(default)")
              for c in p.findall("class"):
                  cc, cm = sum_counter(c, "LINE")
                  total = cc + cm
                  pct = (cc/total*100) if total else 0.0
                  # JaCoCo class nameì€ 'com/foo/Bar' í˜•ì‹
                  cname = c.get("name","(unknown)").replace("/", ".")
                  class_rows.append((pkg, cname, cc, cm, pct, total))
          class_rows.sort(key=lambda r: (r[4], -r[5]))  # ë‚®ì€ ì»¤ë²„ë¦¬ì§€ & ë¼ì¸ ë§ì€ ìˆœ

          # ë³€ê²½ íŒŒì¼ ë§¤í•‘ â†’ FQN í›„ë³´
          changed_map = []  # (sourcePath, fqnCandidate)
          changed_file_list = Path("/tmp/changed-java.txt")
          if changed_file_list.exists():
              for line in changed_file_list.read_text().splitlines():
                  line = line.strip()
                  if not line:
                      continue
                  # src/main/java/com/foo/Bar.java â†’ com.foo.Bar
                  # src/main/kotlin/com/foo/Bar.kt â†’ com.foo.Bar
                  if line.startswith("src/main/java/"):
                      rel = line[len("src/main/java/"):]
                  elif line.startswith("src/main/kotlin/"):
                      rel = line[len("src/main/kotlin/"):]
                  else:
                      continue
                  if rel.endswith(".java"):
                      rel = rel[:-5]
                  elif rel.endswith(".kt"):
                      rel = rel[:-3]
                  fqn = rel.replace("/", ".")
                  changed_map.append((line, fqn))

          # JaCoCo XMLì—ì„œ í•´ë‹¹ FQNìœ¼ë¡œ ì‹œì‘í•˜ëŠ” í´ë˜ìŠ¤ë§Œ í•„í„°ë§ (Kotlin ë‹¤ì¤‘ í´ë˜ìŠ¤/íŒŒì¼ë„ ì»¤ë²„ë¨)
          changed_rows = []
          if changed_map:
              for src, fqn in changed_map:
                  # fqnìœ¼ë¡œ ì‹œì‘í•˜ëŠ” ëª¨ë“  í•­ëª© ì§‘ê³„
                  matches = [r for r in class_rows if r[1].startswith(fqn)]
                  if matches:
                      # ë™ì¼ ì†ŒìŠ¤ ê¸°ì¤€ í•©ì‚°
                      cov = sum(m[2] for m in matches)
                      miss = sum(m[3] for m in matches)
                      total = cov + miss
                      pct = (cov/total*100) if total else 0.0
                      changed_rows.append((src, fqn, cov, miss, pct, total))
                  else:
                      # ë§¤ì¹­ ì—†ëŠ” ê²½ìš°ë„ í‘œì— í‘œì‹œ
                      changed_rows.append((src, fqn, 0, 0, 0.0, 0))
              # ì»¤ë²„ë¦¬ì§€ ë‚®ì€ ìˆœ, ë¼ì¸ ë§ì€ ìˆœ
              changed_rows.sort(key=lambda r: (r[4], -r[5]))

          def fmt_pct(x): return f"{x:.2f}%"

          print("### ğŸ“Š Coverage Details\n")
          print(f"**Overall Line Coverage:** {fmt_pct(tot_pct)} ({tot_cov} covered / {tot_cov+tot_miss} lines)\n")

          if pkg_rows:
              print("<details><summary><b>Package Summary (lowest first)</b></summary>\n")
              print("| Package | Line % | Covered | Missed |")
              print("|---|---:|---:|---:|")
              for (name, cov, miss, pct) in pkg_rows:
                  print(f"| `{name}` | {fmt_pct(pct)} | {cov} | {miss} |")
              print("\n</details>\n")

          print("<details open><summary><b>Lowest Covered Classes (Top 20)</b></summary>\n")
          print("| Class | Line % | Covered | Missed |")
          print("|---|---:|---:|---:|")
          for (pkg, cname, cov, miss, pct, total) in class_rows[:20]:
              print(f"| `{cname}` | {fmt_pct(pct)} | {cov} | {miss} |")
          print("\n</details>\n")

          if changed_map:
              print("<details open><summary><b>Changed Classes (from this PR)</b></summary>\n")
              print("| Source (PR) | Class Prefix | Line % | Covered | Missed |")
              print("|---|---|---:|---:|---:|")
              for (src, fqn, cov, miss, pct, total) in changed_rows:
                  print(f"| `{src}` | `{fqn}` | {fmt_pct(pct)} | {cov} | {miss} |")
              print("\n</details>\n")
          PY

          {
            echo 'details<<EOF'
            cat /tmp/coverage_details.md
            echo 'EOF'
          } >> $GITHUB_OUTPUT

      - name: Upsert PR comment (coverage)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          PCT: ${{ steps.cov.outputs.pct }}
          DETAILS: ${{ steps.covmd.outputs.details }}
        with:
          script: |
            const MARK = '<!-- JACOCO-COVERAGE-SUMMARY -->';
            const pct = process.env.PCT || '0';
            const details = process.env.DETAILS || '';
            const runUrl = `https://github.com/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}`;
            const body = `${MARK}
            ### ğŸ§ª JaCoCo Coverage
            **Line Coverage:** ${pct}%

            ${details}

            ğŸ”— **Full HTML report**: See artifact **jacoco-full-html** on this run â†’ ${runUrl}
            `;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              per_page: 100
            });
            const existing = comments.find(c => c.user.type === 'Bot' && c.body.includes(MARK));
            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body
              });
            }