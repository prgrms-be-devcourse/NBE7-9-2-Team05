name: Backend CI

on:
  pull_request:
    paths:
      - "motionit/**"
      - ".github/**"
  push:
    branches: [ main, develop ]

permissions:
  contents: read
  checks: write
  pull-requests: write

jobs:
  backend-test:
    runs-on: ubuntu-latest

    defaults:
      run:
        working-directory: motionit

    # üîë Ïó¨Í∏∞ÏÑú GitHub Secrets ‚Üí SpringÏù¥ Ï∞∏Ï°∞ÌïòÎäî ÌôòÍ≤ΩÎ≥ÄÏàòÎ™ÖÏúºÎ°ú Îß§Ìïë
    # application.yml Ïùò ${...} ÌÇ§ÏôÄ "Ï†ïÌôïÌûà Í∞ôÏùÄ Ïù¥Î¶Ñ"ÏúºÎ°ú ÎëêÎ©¥ .env ÏóÜÏù¥ÎèÑ ÎèôÏûëÌï©ÎãàÎã§.
    env:
      # Spring Ïã§Ìñâ ÌîÑÎ°úÌïÑ: CI/H2Ïö©
      SPRING_PROFILES_ACTIVE: test
      # H2Î°ú ÌÖåÏä§Ìä∏ (ÌïÑÏöî Ïãú YourTestConfigÏóê ÎßûÍ≤å Ï°∞Ï†ï)
      SPRING_DATASOURCE_URL: jdbc:h2:mem:testdb;MODE=MySQL;DB_CLOSE_DELAY=-1;DATABASE_TO_UPPER=false
      SPRING_DATASOURCE_USERNAME: sa
      SPRING_DATASOURCE_PASSWORD: ""

      # ====== appÏóêÏÑú Ï∞∏Ï°∞ÌïòÎäî ÌÇ§Îì§ ======
      AWS_ACCESS_KEY:        ${{ secrets.AWS_ACCESS_KEY }}
      AWS_SECRET_KEY:        ${{ secrets.AWS_SECRET_KEY }}
      AWS_S3_BUCKET_NAME:    ${{ secrets.AWS_S3_BUCKET_NAME }}
      AWS_CLOUDFRONT_DOMAIN: ${{ secrets.AWS_CLOUDFRONT_DOMAIN }}
      AWS_CLOUDFRONT_KEY_ID: ${{ secrets.AWS_CLOUDFRONT_KEY_ID }}
      # CloudFront ÌîÑÎùºÏù¥ÎπóÌÇ§Îäî Î≥¥ÌÜµ ÌååÏùº Í≤ΩÎ°úÍ∞Ä ÌïÑÏöîÌï©ÎãàÎã§.
      # ÌÖåÏä§Ìä∏ÏóêÏÑúÎäî ÏÇ¨Ïö©ÌïòÏßÄ ÏïäÍ≤å Î∂ÑÍ∏∞ÌïòÎäî Ìé∏Ïù¥ ÏïàÏ†ÑÌïòÏßÄÎßå,
      # ÏûÑÏãúÎ°ú /tmp/key.pem Í≤ΩÎ°úÏóê Ïç®ÎëêÍ≥† Í≤ΩÎ°úÎßå Ï£ºÏûÖÌï¥ÎèÑ Îê©ÎãàÎã§. (ÏïÑÎûò "ÏòµÏÖò: ÌÇ§ ÌååÏùº ÏÉùÏÑ±" Ï∞∏Í≥†)
      AWS_CLOUDFRONT_PRIVATE_KEY_PATH: /tmp/cloudfront_key.pem
      AWS_CLOUDFRONT_PRIVATE_KEY_PEM: ${{ secrets.AWS_CLOUDFRONT_PRIVATE_KEY_PEM }}

      JWT_SECRET:               ${{ secrets.JWT_SECRET }}
      JWT_ACCESS_TOKEN_EXPIRATION: "3600"
      JWT_REFRESH_TOKEN_EXPIRATION: "1209600"

      OPENAI_API_KEY:         ${{ secrets.OPENAI_API_KEY }}
      YOUTUBE_API_KEY:        ${{ secrets.YOUTUBE_API_KEY }}
      KAKAO_CLIENT_ID:        ${{ secrets.KAKAO_CLIENT_ID }}

      # ÌîÑÎ°†Ìä∏ Î¶¨Îã§Ïù¥Î†âÌä∏ Ï£ºÏÜå Îì± ÌÖåÏä§Ìä∏Ïö© Í∏∞Î≥∏Í∞í
      # ÌïÑÏöîÏãú SecretsÎ°ú ÎπºÎèÑ Îê®
      # app.oauth2.redirect-urlÏùÄ application.ymlÏóê ÏÉÅÏàòÎ°ú ÏûàÏúºÎãà Î≥¥ÌÜµ Î∂àÌïÑÏöî

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Java 21
        uses: actions/setup-java@v4
        with:
          distribution: temurin
          java-version: 21

      - name: Grant execute permission for Gradle Wrapper
        run: chmod +x gradlew

      - name: Write application-test.yml from secret
        working-directory: motionit
        run: |
          mkdir -p src/test/resources
          cat > src/test/resources/application-test.yml <<'YAML'
          ${{ secrets.APPLICATION_TEST_YML }}
          YAML

      - name: Show test resources
        working-directory: motionit
        run: ls -al src/test/resources || true

      - name: Ensure application-test.yml exists (fallback)
        working-directory: motionit
        run: |
          FILE=src/test/resources/application-test.yml
          if [ ! -s "$FILE" ]; then
            echo "application-test.yml secret missing, writing fallback..."
            mkdir -p src/test/resources
            cat > "$FILE" <<'YAML'
            spring:
              datasource:
                url: jdbc:h2:mem:testdb;MODE=MySQL;DB_CLOSE_DELAY=-1;DATABASE_TO_UPPER=false
                username: sa
                password:
              jpa:
                hibernate:
                  ddl-auto: create-drop
                properties:
                  hibernate:
                    format_sql: true
              h2:
                console:
                  enabled: true
            app:
              oauth2:
                enabled: false
              aws:
                enabled: false
              cloudfront:
                enabled: false
            YAML
          fi
          echo "-------- application-test.yml --------"
          cat "$FILE"

      # (ÏòµÏÖò) CloudFront ÌîÑÎùºÏù¥Îπó ÌÇ§ ÌååÏùº ÏÉùÏÑ± ‚Äî ÌÖåÏä§Ìä∏ ÏΩîÎìúÍ∞Ä Ìï¥Îãπ ÌååÏùºÏùÑ Ï†ëÍ∑ºÌïúÎã§Î©¥ ÌïÑÏöî
      - name: Write CloudFront private key (optional)
        if: ${{ env.AWS_CLOUDFRONT_PRIVATE_KEY_PATH != '' && env.AWS_CLOUDFRONT_PRIVATE_KEY_PEM != '' }}
        run: |
          printf "%s" "$AWS_CLOUDFRONT_PRIVATE_KEY_PEM" > "$AWS_CLOUDFRONT_PRIVATE_KEY_PATH"
          chmod 600 "$AWS_CLOUDFRONT_PRIVATE_KEY_PATH"

      # Ï†ÑÏ≤¥(Îã®ÏúÑ+ÌÜµÌï©) Ïã§Ìñâ
      - name: Run Full Test
        run: ./gradlew --no-daemon clean fullTest --info --stacktrace

      - name: Print active profile and where config loaded
        if: always()
        run: |
          echo "SPRING_PROFILES_ACTIVE=$SPRING_PROFILES_ACTIVE"
          grep -R --line-number "app\\." -n motionit/src/test/resources || true

      - name: Generate JaCoCo (fullTest)
        run: ./gradlew jacocoFullTestReport

      # Ïã§Ìå®/ÏÑ±Í≥µÍ≥º Î¨¥Í¥ÄÌïòÍ≤å Î¶¨Ìè¨ÌåÖ Îã®Í≥ÑÎäî ÏßÑÌñâ
      - name: Publish Unit Test Results (JUnit)
        if: always()
        uses: EnricoMi/publish-unit-test-result-action@v2
        with:
          files: |
            motionit/build/test-results/test/*.xml
            motionit/build/test-results/fullTest/*.xml
          check_run: true
          comment_mode: always

      - name: Upload failed-tests.txt (if exists)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: failed-tests
          path: motionit/build/reports/tests/failed-tests.txt
          if-no-files-found: ignore

      - name: Upsert PR comment with failed tests
        if: always()
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const path = 'motionit/build/reports/tests/failed-tests.txt';
            const MARK = '<!-- FAILED-TESTS-SUMMARY -->';

            function buildBody(textBlock) {
              return [
                MARK,
                '### ‚ùå Failed Tests (from Gradle summary)',
                '',
                '<details><summary>Expand</summary>',
                '',
                '```text',
                textBlock,
                '```',
                '',
                '</details>'
              ].join('\n');
            }

            if (!context.payload.pull_request) {
              core.info('Not a PR event, skip commenting');
              return;
            }

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              per_page: 100
            });

            // ÌååÏùºÏù¥ ÏóÜÍ±∞ÎÇò, No failuresÎ©¥ Í∏∞Ï°¥ ÎßàÏª§ ÎåìÍ∏Ä ÏÇ≠Ï†ú
            if (!fs.existsSync(path)) {
              const existing = comments.find(c => c.user.type === 'Bot' && c.body.includes(MARK));
              if (existing) {
                await github.rest.issues.deleteComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existing.id
                });
              }
              return;
            }

            const content = fs.readFileSync(path, 'utf8').trim();
            if (!content || content === 'No failures üéâ') {
              const existing = comments.find(c => c.user.type === 'Bot' && c.body.includes(MARK));
              if (existing) {
                await github.rest.issues.deleteComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: existing.id
                });
              }
              return;
            }

            const body = buildBody(content);
            const existing = comments.find(c => c.user.type === 'Bot' && c.body.includes(MARK));
            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body
              });
            }

      - name: Upload JaCoCo HTML
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: jacoco-full-html
          path: motionit/build/reports/jacocoFull/html
          if-no-files-found: warn

      - name: Install xmllint
        if: always()
        run: sudo apt-get update && sudo apt-get install -y libxml2-utils

      - name: Compute coverage & upsert PR comment
        if: always() && github.event_name == 'pull_request'
        id: cov
        run: |
          # ÌïòÎÇòÏùò Î¶¨Ìè¨Ìä∏Î°ú Ïòà: fullTest Í∏∞Ï§Ä
          XML="motionit/build/reports/jacocoFull/xml/jacocoFullTestReport.xml"
          if [ ! -f "$XML" ]; then
            echo "XML not found: $XML"
            echo "pct=0" >> $GITHUB_OUTPUT
            exit 0
          fi

          COVERED=$(xmllint --xpath "string(sum(//counter[@type='LINE']/@covered))" "$XML")
          MISSED=$(xmllint --xpath "string(sum(//counter[@type='LINE']/@missed))" "$XML")
          TOTAL=$(( ${COVERED%.*} + ${MISSED%.*} ))
          if [ "$TOTAL" -eq 0 ]; then
            PCT=0
          else
            # ÏÜåÏàòÏ†ê 2ÏûêÎ¶¨
            PCT=$(awk "BEGIN { printf \"%.2f\", ($COVERED/($COVERED+$MISSED))*100 }")
          fi
          echo "pct=$PCT" >> $GITHUB_OUTPUT
        shell: bash

      - name: Upsert PR comment (coverage)
        if: always() && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        env:
          PCT: ${{ steps.cov.outputs.pct }}
        with:
          script: |
            const MARK = '<!-- JACOCO-COVERAGE-SUMMARY -->';
            const pct = process.env.PCT || '0';
            const body = `${MARK}
            ### üß™ JaCoCo Coverage
            **Line Coverage:** ${pct}%`;

            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              per_page: 100
            });
            const existing = comments.find(c => c.user.type === 'Bot' && c.body.includes(MARK));
            if (existing) {
              await github.rest.issues.updateComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: existing.id,
                body
              });
            } else {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body
              });
            }